<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>番茄是一只猫的博客</title>
  
  <subtitle>Say something</subtitle>
  <link href="https://mryulong.github.io/atom.xml" rel="self"/>
  
  <link href="https://mryulong.github.io/"/>
  <updated>2022-02-23T06:30:01.522Z</updated>
  <id>https://mryulong.github.io/</id>
  
  <author>
    <name>番茄是一只猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码注入</title>
    <link href="https://mryulong.github.io/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>https://mryulong.github.io/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</id>
    <published>2022-02-19T06:18:07.000Z</published>
    <updated>2022-02-23T06:30:01.522Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入，顾名思义就是把代码逻辑注入到目标程序中，以达到修改现有逻辑的目的，是 APP 逆向验证的最后一步。下面针对机器越狱与否，具体说说都有什么方案。</p><span id="more"></span><h2 id="越狱机"><a href="#越狱机" class="headerlink" title="越狱机"></a>越狱机</h2><p>在 iOS 越狱机中，代码注入相对灵活的多，毕竟权限要大得多，比较常见的就是：直接下载各种商店 Cydia、Sileo，安装 deb 格式的安装包，就实现了代码注入。</p><h3 id="deb-包"><a href="#deb-包" class="headerlink" title="deb 包"></a>deb 包</h3><p>简单的说说这个过程，从 deb 安装包开始说起，这是什么格式的，怎么起作用的？</p><blockquote><p>deb 格式是 Debian 系统(包含 Debian 和 Ubuntu )专属安装包格式，配合 APT 软件管理系统，成为了当前在 Linux 下非常流行的一种安装包。</p></blockquote><h4 id="deb-文件结构"><a href="#deb-文件结构" class="headerlink" title="deb 文件结构"></a>deb 文件结构</h4><p>先看看一个完整的插件包里究竟放着哪些文件，我们修改他的后缀为 zip，解压看看。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/deb-1.jpg" alt="deb-1"></p><p>上图可以看到里面两个子文件夹，DEBIAN 和 Library。前者里面放着 control 文件，记录安装包基本信息：包名、作者之类。具体内容如下图所示：</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/deb-3.jpg" alt="deb-3"></p><p>另外一个是 Library/MobileSubstrate/DynamicLibraries 目录下，放着 plist 和 dylid 文件，二者同名，一个信息文件，一个动态库。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/deb-2.jpg" alt="deb-2"><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/deb-4.jpg" alt="deb-4"></p><h4 id="deb-加载的流程："><a href="#deb-加载的流程：" class="headerlink" title="deb 加载的流程："></a>deb 加载的流程：</h4><p>deb 插件安装成功后，这一对文件会被拷贝到手机 /Library/MobileSubstrate/DynamicLibraries/ 目录下，等待启动注入。从这里到启动发生了什么呢？就不得不提一个越狱机安装的框架：<a href="http://www.cydiasubstrate.com/">Cydia Substrate</a>，以前叫 MobileSubstrate，它是 Cydia 实现的基础，现有的越狱开发环境一般使用的是 THEOS 或者 iOSOpenDev，这两者 hook 功能都是对 MobileSubstrate API 的封装。而 MobileSubstrate 又是基于 DYLD_INSERT_LIBRARIES 方式实现的。MobileSubstrate 具体有三部分组成：</p><ul><li>MobileHooker：用来替换系统函数。</li><li>safe mode：当编写的扩展导致 SpringBoard crash 的时候，MobileLoader 会捕获这个异常，然后让设备进入安全模式。</li><li>MobileLoader：把第三方补丁程序加载进入运行的程序中。</li></ul><p>MobileLoader 大概工作原理：首页会通过 DYLD_INSERT_LIBRARIES 把自己加载进目标程序，然后它会查看 /Library/MobileSubstrate/DynamicLibraries/ 下动态库，具体加载哪个，然后还记得上面说的文件夹下两个同名文件吗？ 其中的 plist 文件中 Filter/Bundles 字段下存放着注入的目标程序的 bundleid, 命中后 MobileLoader 就会通过 dlopen 函数打开对应的 dylib 文件，完成了代码注入。</p><p>如果想自己修改注入, 其实我们自己也可以尝试开发，现在工具比较丰富，比如：</p><ul><li>MonkeyDev 同 iOSOpenDev 一样，提供了 Xcode 模板，同样简单易用。（左图）</li><li>THEOS，通过简单的命令行就可以创建模板，开发完成 make package，打包完成即可。（右图）</li></ul><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/thoes-monkey.jpg" class=""></div><div class="group-picture-column"><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/theos-1.jpg" class=""></div></div></div><h3 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h3><p>知道上面的流程后，其实我们直接把我们开发的动态库文件，新建一个 plist 文件，放到 /Library/MobileSubstrate/DynamicLibraries/ 下就可以实现注入，无需通过 deb 包，当然这样在 Cydia 就查看不到安装信息，不便于管理。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/local-in.jpeg"></p><h2 id="非越狱机型"><a href="#非越狱机型" class="headerlink" title="非越狱机型"></a>非越狱机型</h2><p>看过越狱机如此便捷的注入，非越狱机就相当麻烦点，不像越狱机有 Cydia Substrate 框架，那非越狱手机怎么办？只能自己来做框架做的事了，那就是修改 APP 的 Mach-O 文件，动态加载注入代码。下面说说如何进行代码注入。</p><h3 id="自动注入-MonkeyDev"><a href="#自动注入-MonkeyDev" class="headerlink" title="自动注入 MonkeyDev"></a>自动注入 MonkeyDev</h3><p>上面也提到了 MonkeyDev，作为 iOSOpenDev 的升级版， 已经是逆向开发的常用工具，对非越狱机友好，与正常开发无异。通过它我们可以创建 MonkeyApp 模板工程，引入砸过壳的 ipa 包，编写需要注入的代码逻辑，连接真机 command + R， 就实现了代码注入。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/MonkeyDev.jpg" alt="MonkeyDev"></p><h3 id="手动注入-1"><a href="#手动注入-1" class="headerlink" title="手动注入"></a>手动注入</h3><p>手动注入，其实就是手动修改 Mach-O 文件，工具当然也有很多，下面介绍两款我使用过的。</p><h4 id="yololib"><a href="#yololib" class="headerlink" title="yololib"></a>yololib</h4><p><a href="https://github.com/KJCracks/yololib/releases">yololib</a> 是一个 dylib 注入工具，利用这个工具，大大方便我们修改 Mach-O 文件的 Load Command。以达到注入动态库的目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./yololib [binary] [dylib file]</span><br><span class="line">./yololib [被插入dylib的二进制文件] [要插入的dylib]</span><br></pre></td></tr></table></figure><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>然而，很尴尬我实践的时候遇到提示成功，实际上查看二进制文件却是乱码，注入失败问题，这个工具最后一次提交已经是 15 年了，太久没维护了，确实也没找到原因。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/yo-fa-1.jpg"></p><h4 id="optool"><a href="#optool" class="headerlink" title="optool"></a>optool</h4><p><a href="https://github.com/alexzielenski/optool">optool</a> 和 yololib 同样是 dylib 注入工具，不仅可以注入，还支持移除，简单的命令就可以完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新增 (executable_path为固定字符，不能更改)</span><br><span class="line">optool install -c load -p @executable_path/xxx.dylib -t /xxx.app/xxx</span><br><span class="line"></span><br><span class="line">// 移除</span><br><span class="line">optool uninstall -p @executable_pach/XXX.dylib -t TargetApp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/op-su-1.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们也完成了非越狱机的注入，但是还有一步需要做就是重签，非越狱机无法像越狱机一样拥有 AppSync 插件越过签名校验，所以必须删除 PlugIns，然后包括 framework 在内的完全签名才可以正常使用。签名工具很多不多做描述了，比如：图形界面 ：<a href="https://github.com/DanTheMan827/ios-app-signer">App Signer</a>、命令行： Codesign 等等，都可以实现再签名。</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/sign.jpg"></p><p>到这里，动态代码注入就说完了，你可能会发现基本原理都是一样的，无非是让目标程序在启动时候，加载我们的动态库，无论是 dlopen 还是 mach-o 的 Load Command, 都是一样的，万变不离其宗。然而，你我也不过是站在巨人的肩膀上，简单的一行命令行也蕴含着很多人默默付出，渺小而伟大，感谢大神的轮子。</p><p>学习之路漫漫，继续加油！Hello World!!</p><p><img src="/2022/02/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/success.jpeg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入，顾名思义就是把代码逻辑注入到目标程序中，以达到修改现有逻辑的目的，是 APP 逆向验证的最后一步。下面针对机器越狱与否，具体说说都有什么方案。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="逆向" scheme="https://mryulong.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="越狱" scheme="https://mryulong.github.io/tags/%E8%B6%8A%E7%8B%B1/"/>
    
  </entry>
  
  <entry>
    <title>iOS 逆向二三事</title>
    <link href="https://mryulong.github.io/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://mryulong.github.io/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2019-08-21T12:09:23.000Z</published>
    <updated>2022-02-09T03:04:32.046Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一篇已经整四个月了，当我想起来的时候，我想我要再水一篇文章了，就接着上一篇说说逆向吧。最近，看到 github 看到有人做了微信集赞助手，直呼厉害，直击用户需求，有了这个，妙啊。搞一个小工具集吧，把各种功能合并到一起，比如集赞、集评论、修改步数、抢红包、防撤回等，都是些常规功能，网上轮子太多，不做具体逻辑描述。下面记录下一个逆向小白遇到的各种问题。</p><span id="more"></span><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>由于一时冲动吧手机升到了 iOS12，只能不完美越狱，于是就陷入各种坑。</p><h3 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a>dumpdecrypted</h3><p>安装完，运行 app，ssh 上设备， 输入第一个指令查看当前进程，第一个问题上线，<code>Bad CPU type in executable</code>，一通搜索，把 adv-cmds 降级安装可解决，操作后，当我再次输入，<code>ps -e</code> 完美展示，可以，继续。<br><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/ps-e.png"><br>然后，<code>cycript -p 6014</code> 再次报错，GG。再次一通搜索，原来是 iOS12 不完美越狱的问题，替代方法是直接 <code>Cydia</code> 安装 <code>Filza</code> 找到 <code>/var/mobile/Containers/Data/Application/</code> 目录，因为这里会显示应用的名字。<br><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/ps-e-s-i.png"></p><p>到这里继续下去的步骤我是拒绝的，不知道还会遇到什么，都 9012 年了，我想应该有一个简单的方法，，于是我找到了它，<strong>CrackerXI</strong> ，直接 <code>Cydia</code> 安装，选中要砸壳的应用，就会在<code>Document</code>目录生成 ipa，助手导出即可，完美，此时我内心是平静的。其实，直接从 PP 助手上下载越狱应用也是一个不错的方法，会省下很多功夫。</p><h3 id="砸壳检测"><a href="#砸壳检测" class="headerlink" title="砸壳检测"></a>砸壳检测</h3><p>检测砸壳是否成功，从结果图中我们找到_64 结尾的那段，cryptid 标记是否已经加密，1：标识有加密，0：表示未加密。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l WeChat.app/WeChat | grep -B 2 crypt</span><br></pre></td></tr></table></figure><p><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/dumpinfo.jpg" alt="检测结果"></p><h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>这一步很重要，以前并没有注意到，如果不是自己下载、砸壳得到的 ipa，不排除被别人修改过，存在安全问题，操作起来也很简单，直接终端输入下面指令，就可以查看相应签名信息了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -d -vv   [path] .app</span><br></pre></td></tr></table></figure><p><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/codesign.jpg" alt="签名详情"></p><p>查看 CPU 架构，分离出 arm64 架构，替换原有，便于下面还原调用栈符号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看支持架构</span><br><span class="line">lipo -info appname.app/appname</span><br><span class="line">// 分离出 arm64</span><br><span class="line">lipo appname.app/appname -thin arm64 -output appname.app/appname.arm64</span><br></pre></td></tr></table></figure><p><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/fatApp.jpg" alt="fat file"></p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h3><p>新建 MonkeyApp ，选中真机调试，然后打开 Reveal，会提醒版本太老，因为项目集成的 framework 是<code>/opt/MonkeyDev/frameworks</code>目录下的，可能存在和你当前电脑安装版本的 Reveal 版本不一致问题，找到 Reveal 中 framework 替换掉 <code>/opt/MonkeyDev/frameworks</code> 目录下面，再次编译即可。</p><p>如果没有安装 Reveal , 可以尝试 Xcode 自带的 Debug View Hierarchy 也很友好，或者 Cocoapods 安装 FLEX 也是可以替代的，在功能上还要丰富，可以给逆向分析提供更多的信息。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/FLEX1.PNG" class=""></div><div class="group-picture-column"><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/FLEX2.PNG" class=""></div><div class="group-picture-column"><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/FLEX3.PNG" class=""></div></div></div><h3 id="事件获取、追踪"><a href="#事件获取、追踪" class="headerlink" title="事件获取、追踪"></a>事件获取、追踪</h3><p>如果是按钮事件，我们肯定要先找到它的点击相应事件，Reveal 查看按钮内存地址，然后依次<code>allTargets</code>、<code>allControlEvents</code>、<code>actionsForTarget:forControlEvent:</code>，拿到按钮的事件。</p><p><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/butonAction.png"></p><p>下面，就是拿到完整调用栈，两种方法，</p><ul><li>第一：hook 按钮方法，xcode 添加断点，然后 <code>bt</code> 获得调用栈.</li><li>第二：基于 <code>ANYMethodLog</code> 工具输出指定方法调用之前的所有被调用的方法，但是这里有个弊端，就是你必须知道在这之前用到哪些 class ，否则不可能指定 NSObject，那样干扰就太多了。</li></ul><p>所以我选择在第一种方法知道 class 信息之后，通过第二种方法同时输出调用方法和调用参数，这样要更加清晰明了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame #<span class="number">1</span>: <span class="number">0x00000001055ae26c</span> neteasemusic`___lldb_unnamed_symbol58736$$neteasemusic + <span class="number">3020</span></span><br><span class="line">frame #<span class="number">2</span>: <span class="number">0x0000000105aa368c</span> neteasemusic`___lldb_unnamed_symbol84628$$neteasemusic + <span class="number">180</span></span><br><span class="line">frame #<span class="number">3</span>: <span class="number">0x0000000104d8379c</span> neteasemusic`___lldb_unnamed_symbol18823$$neteasemusic + <span class="number">1788</span></span><br><span class="line">frame #<span class="number">4</span>: <span class="number">0x00000001051c3c10</span> neteasemusic`___lldb_unnamed_symbol39751$$neteasemusic + <span class="number">256</span></span><br><span class="line">frame #<span class="number">5</span>: <span class="number">0x00000001057f10f0</span> neteasemusic`___lldb_unnamed_symbol71015$$neteasemusic + <span class="number">536</span></span><br></pre></td></tr></table></figure><p>但是拿到的全是符号化之后十六进制的地址，并看不到代码，需要反查 出 hopper 中的反汇编地址。<br><code>反汇编地址 = 内存地址 - 基地址偏移</code>，可以还原出上面调用栈的方法名。 <code>image list -o -f | grep appname</code> 可以拿到基地址偏移。<br><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/methodTrack.jpg"><br>剩下的就剩下计算还原啦，根据计算，拿到的结果如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span>c8000 基地址</span><br><span class="line"><span class="number">0x00000001055ae26c</span>  <span class="number">100</span>BE626C   -[NMSong copyWithZone:]:</span><br><span class="line"><span class="number">0x0000000105aa368c</span>   <span class="number">1010</span>DB68C+[NMID3Wrapper writeID3ForSong:filePath:]:</span><br><span class="line"><span class="number">0x0000000104d8379c</span>   <span class="number">1003</span>BB79C-[NMDownloadID3Writer write]</span><br><span class="line"><span class="number">0x00000001051c3c10</span><span class="number">1007</span>FBC10 -[NMSongDownloadJob downloadFinished:]</span><br><span class="line"><span class="number">0x00000001057f10f0</span><span class="number">100E290</span>F0-[NMDownloadRequest downloadRequestFinished:responseTime:downloadSpeed:]</span><br></pre></td></tr></table></figure><h3 id="逻辑分析、代码编写"><a href="#逻辑分析、代码编写" class="headerlink" title="逻辑分析、代码编写"></a>逻辑分析、代码编写</h3><p>到达这一步后，剩下的分析，其实有很大一部分是基于猜的部分，当然也不是毫无根据的猜，需要丰富的代码经验，假设自己是开发者会怎么写相关逻辑，然后是反复验证自己的想法，不断地失败，知道找到合适的方法。</p><p>比如我在逆向网易云音乐时候，我想让付费的音乐也可以正常下载，从点击下载按钮的那一个事件开始追踪、分析。</p><p>首先我注意到 NMSong 有个属性 <code>NMSongUrlInfo *downloadUrlInfo</code>，毫无疑问这个是用来下载的数据来源，但是我点进歌单打开对应歌曲菜单这个信息还是空的，我在下载点击处打了断点，发现 由<code>NMSongDownloadJob</code> 负责下载音乐，追踪初始化对象时候，还是没有下载地址，肯定是 <code>NMSongDownloadJob</code> 内部处理了下载地址逻辑 ，原来是单独接口获取的，调用 <code>NMSongUrlInfoFixer</code> 组装成 <code>NMSongUrlInfoRequest</code> 负责请求下载 url , <code>NMSongUrlInfoRequest</code> 继承于 <code>NMBaseRequest</code>， <code>NMBaseRequest</code> 继承于 基类 <code>NMHttpRequest</code>，直接一步到位 hook 了 <code>parseResult</code> 方法，加上断点，查看了 request 对象的所有请求信息，后端根据 songid 、登陆用户信息，决定是否返回下载链接，这样搞，想通过修改参数获取下载连接的路就死了，没办法了，又从头开始看 NMSong 。</p><p>然后发现了 <code>NMSongCacheUrlInfo *playUrlInfo</code>，hook set 方法，添加断点，看看什么时候被赋值，毕竟可以播放，这个属性总是要有内容的，点击播放，断点进来了，看到了所有播放用到的音频 url 信息，完美，下面只需要把播放信息给到下载信息里面，然后直接下载播放的音频地址即可。<br>至此，完成了收费音乐的下载，不足就是必须在播放页触发播放，拿到播放信息后才能下载，其实我想还是可以优化下，比如其他页面点击下载时候，触发播放行为，又或者直接调用请求播放信息的接口，然后实现资源下载，然而再也提不起兴趣了，毕竟普通下载已经没有问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实验的结果稍微有点不尽如人意，比如：费力搞好微信，发现重签后的微信因为证书问题 remote push 收不到了；网易云音乐也不能批量的下载，有点遗憾。</p><p>以上可见，逆向分析的过程是琐碎而枯燥的，需要反复的思考、尝试。然而，逆向可以窥探和修改别人代码，让我见识到别人代码的布局思路，底层代码的封装，架构的完整，从而发现自己不足，在技术方面有了更深的认识。前路漫漫，唯有上下求索，继续努力。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/wechat_tool.PNG" class=""></div><div class="group-picture-column"><img src="/2019/08/21/iOS-%E9%80%86%E5%90%91%E4%BA%8C%E4%B8%89%E4%BA%8B/wechat_tool_1.PNG" class=""></div></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离上一篇已经整四个月了，当我想起来的时候，我想我要再水一篇文章了，就接着上一篇说说逆向吧。最近，看到 github 看到有人做了微信集赞助手，直呼厉害，直击用户需求，有了这个，妙啊。搞一个小工具集吧，把各种功能合并到一起，比如集赞、集评论、修改步数、抢红包、防撤回等，都是些常规功能，网上轮子太多，不做具体逻辑描述。下面记录下一个逆向小白遇到的各种问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="踩坑" scheme="https://mryulong.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="逆向" scheme="https://mryulong.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>TikTok 逆向记录</title>
    <link href="https://mryulong.github.io/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://mryulong.github.io/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/</id>
    <published>2019-04-21T02:32:53.000Z</published>
    <updated>2022-02-09T03:04:54.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近接触一款叫 Thor 的软件很好用，类似 Charles 实现手机端抓包软件，可自定义各种规则可以拦截修改请求。网上就出现很多热心朋友分享各种规则规则，通过修改接口开实现破解 App 的效果，接触到一个 TikTok 换区规则激起了我的兴趣。</p><p>看了下规则，大致的原理都是替换请求参数中的 <strong>sys_region</strong> 与 <strong>carrier_region</strong>等字段，这种方法虽好，但如果哪天他们开始接口签名校验不就马上不灵了，不如逆向来的稳妥。然后 GitHub 上找到 <a href="https://github.com/AYJk/AYTikTokPod">AYTikTokPod</a>，正好实践下一个 APP 的一个完整逆向过程，于是有了下面的内容。</p><span id="more"></span><h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><p>逆向开发相对正常开发，只用到一个 xcode 搞定所有，需要的工具很多，从开始想要逆向一个 APP 开始，就要用到一系列的工具，首先配置下环境。</p><h3 id="frida-ios-dump"><a href="#frida-ios-dump" class="headerlink" title="frida-ios-dump"></a>frida-ios-dump</h3><p>由于从 App Store 下载的 ipa 都已经被 Apple 加密了，我们无法直接逆向分析，第一步就需要突破这层限制，就是我们所谓的砸壳。早先砸壳大多使用 <a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a> ，步骤比较麻烦， 基于 <a href="https://www.frida.re/docs/home/">frida</a> 的<a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a> 相对就简单很多，通过注入 js 实现内存 dump，通过 python 自动拷贝到电脑生成 ipa 文件，实现动态砸壳。大致步骤如下，更详细可以参照作者博客：<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/">一条命令完成砸壳</a>。</p><ol><li>安装 frida<br>中间有几次始终卡在 Building wheel for frida (setup.py) ，重试几次搞定又出现错误 Running setup.py bdist_wheel for frida …，提示加上 –user，加上参数解决。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 <a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/frida-ios-dump.git</span><br><span class="line">cd frida-ios-dump</span><br><span class="line">sudo pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure><h3 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h3><p>一款二进制反编译器，非常强大，我也是知道点皮毛，这里我们就用它一个功能，把上面得到的 .app 反编译，生成伪代码，扫描完之后既可以看到左边侧栏的方法调用了。班门弄斧，不再详说。</p><h3 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h3><p>安装 <a href="http://stevenygard.com/projects/class-dump/">class-dump</a></p><ol><li><p>下载 安装包</p></li><li><p>把 class-dump 拷贝到 /usr/local/bin ，更改权限</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /usr/local/bin/class-dump</span><br></pre></td></tr></table></figure><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h3><p><a href="%5Bhttp://revealapp.com/download/%5D(https://link.jianshu.com/?t=http://revealapp.com/download/">Reveal</a> 是一个 iOS 程序界面调试工具，它能够在应用程序运行过程中调试应用程序界面。可以帮组我们看到当前运行 APP 的 UI 层级，控件组成等信息，窥探 APP 实现的利器。使用方法也很简单，只用把 RevealService.framework 放入项目跑起来，然后 USB 连接电脑就可以在 Reveal 的界面看到当前程序了，当然如果手机是越狱手机，就更可以一劳永逸了，比如：<a href="https://www.jianshu.com/p/1d63866467e5">这样</a>，由于手边没有越狱手机，还没有实践过。</p><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/reveal.jpg" alt="Reveal"></p><h3 id="Tweak-语法"><a href="#Tweak-语法" class="headerlink" title="Tweak 语法"></a>Tweak 语法</h3><p>简单说下 Tweak 代码语法，这次接触到 Logos 和 CaptainHook ，总体来说使用起来很方便，简单说下语法规则，大神请绕道。</p><h4 id="CaptainHook"><a href="#CaptainHook" class="headerlink" title="CaptainHook"></a>CaptainHook</h4><p>常用语法可以参考<a href="https://github.com/rpetrich/CaptainHook/wiki">CaptainHook</a>文档，基于 runtime method swizzling，使用流程也比较简单，使用步骤大概就是 CHDeclareClass 声明 Hook 类， CHMethod 方法替换，在这里可以 CHSuper 来调用原来的方法，CHConstructor 加载 Hook 的方法和所在的类。下面是 hook UIViewController 的摇一摇回调方法的代码，可以参考下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 声明需要Hook的类</span><br><span class="line">CHDeclareClass(UIViewController)</span><br><span class="line"></span><br><span class="line">// 方法Hook的实现</span><br><span class="line">CHMethod2(void, UIViewController, motionEnded, UIEventSubtype, motion, withEvent, UIEvent *, event) &#123;</span><br><span class="line"></span><br><span class="line">  // 调用之前的方法</span><br><span class="line">    CHSuper2(UIViewController, motionEnded, motion, withEvent, event);</span><br><span class="line"></span><br><span class="line"> // hook 代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载Hook的方法和所在的类</span><br><span class="line">CHConstructor &#123;</span><br><span class="line">  // 加载Hook类</span><br><span class="line">    CHLoadLateClass(UIViewController);</span><br><span class="line">  // 声明要 hook 的方法</span><br><span class="line">    CHClassHook2(UIViewController, motionEnded, withEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Logos"><a href="#Logos" class="headerlink" title="Logos"></a>Logos</h4><p>常用语法也比较简单，下面列举下常用语法，如果定义 subclass 、新增属性等更丰富的功能可以查看文档很详细 <a href="http://iphonedevwiki.net/index.php/Logos#.25property">Logos</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%hook 类名</span><br><span class="line"></span><br><span class="line">// hook 类的原有方法</span><br><span class="line">- (void)原有方法:(id)arg1 ....&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%new</span><br><span class="line">- (void)新增方法:(id)arg1 .... &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h3 id="MonkeyDev"><a href="#MonkeyDev" class="headerlink" title="MonkeyDev"></a>MonkeyDev</h3><p>上面涉及的工具很多，每个都有不同作用，难免有些繁杂，于是，AloneMonkey 大神的 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 出现了，同事大神也是上面说到的 <a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a> 的作者，🐂 🍺。原有 iOSOpenDev 的升级，非越狱插件开发集成神器！</p><p>工具集成了四个模块 Logos Tweak 、CaptainHook Tweak、Command-line Tool、 MonkeyApp，支持 class-dump 、RevealService.framework 自动导入、插件集成，真真全家桶，也就是说只要把砸完壳的 ipa 拖入项目，就可以开始写 Hook 代码了，支持 <a href="http://iphonedevwiki.net/index.php/Logos#Overview">Logos</a> 和 <a href="https://github.com/rpetrich/CaptainHook/wiki">CaptainHook</a> 语法。具体详细使用教程可以看 <a href="https://github.com/AloneMonkey/MonkeyDev/wiki">WiKi</a>。</p><h2 id="开始逆向"><a href="#开始逆向" class="headerlink" title="开始逆向"></a>开始逆向</h2><p>下面是整个逆向的过程，工具介绍完了，步骤就没什么好说的了，基本上 MonkeyDev 搞定一切， 👍。</p><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>使用上面介绍的 frida-ios-dump 完成砸壳，拿到 TikTok 的 ipa，具体步骤：</p><ol><li>将越狱设备通过 USB 连上电脑进行端口映射</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br></pre></td></tr></table></figure><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/port.png" alt="运行程序"></p><ol start="2"><li>砸壳</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dump.py -l    // 打开想要砸壳的应用，查看当前运行的程序</span><br></pre></td></tr></table></figure><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/dump_l.jpg" alt="运行程序"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dump.py  AppName / Bundle identifier  // 会在同级目录生成  xxx.ipa</span><br></pre></td></tr></table></figure><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/dump_b.jpg" class=""></div><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/dump_r.png" class=""></div></div></div><h3 id="class-dump-1"><a href="#class-dump-1" class="headerlink" title="class-dump"></a>class-dump</h3><p>使用 class-dump 指令，拿到所有头文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class-dump -H [.app文件的路径] -o [输出文件夹路径]</span><br></pre></td></tr></table></figure><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/class-dump.png" alt="class-dump"></p><p>如果不采用这种方式，还可以在 MonkeyApp 项目里的 <code>Build Settings</code> 里打开 MONKEYDEV_CLASS_DUMP 功能，重新编译即可在项目目录里找到。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/MonkeyDevSetting.jpg" class=""></div><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/monkey_class-dump.jpg" class=""></div></div></div><h3 id="Hook-部分"><a href="#Hook-部分" class="headerlink" title="Hook 部分"></a>Hook 部分</h3><p>我们新建 MonkeyApp , 然后拖入 ipa 到 <code>TargetApp</code> 文件夹 。</p><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/initProject.jpg"></p><p>打开 MonkeyAppDylib.m ，使用 CaptainHook 语法书写 hook 部分代码，这里主要代码是来自 <a href="https://github.com/AYJk/AYTikTokPod">AYTikTokPod</a>，我把入口改为摇一摇触发设置界面显示。说到这里不得不提一下，MonkeyDev 支持 Cocoapods，并且作者有维护一个叫 <a href="https://github.com/AloneMonkey/MonkeyDevSpecs">MonkeyDevSpecs</a> 的 Cocoapods 私有仓库，让插件集成变得更加简单。</p><p><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/CaptainHook_b.jpg"></p><h3 id="打包安装"><a href="#打包安装" class="headerlink" title="打包安装"></a>打包安装</h3><p>MonkeyDev 提供一键打包脚本，<code>Build Succeeded</code> 后，在根目录文件下，点击 <code>项目目录/LatestBuild/createIPA.command</code> 搞定，稍等就会生成 ipa 文件。<br><a href="https://github.com/MrYulong/TikTokMonkeyApp"></a></p><p>至此，换区和缓存功能都完成了，然后后面就躺在手机里，果然外国的小姐姐也吸引不了我，最后放两张效果图：</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/region.PNG" class=""></div><div class="group-picture-column"><img src="/2019/04/21/TikTok-%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/iphone.PNG" class=""></div></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，这次逆向是顺利的，一来 MonkeyDev 工具实在是太方便 ，二来逆向的思路 <a href="https://github.com/AYJk/AYTikTokPod">AYTikTokPod</a> 已经提供，我就是简单程式化的体验了各个工具的使用和安装，虽然也遇到各种各样的坑，仍然是一个愉快探索过程，后面尝试自己独立逆向分析其他 App 完成一个自己的功能，加油。</p><p>项目完整代码 <a href="https://github.com/MrYulong/TikTokMonkeyApp">TikTokMonkeyApp</a> ，有兴趣可以下载看下。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/AloneMonkey/MonkeyDev/wiki">https://github.com/AloneMonkey/MonkeyDev/wiki</a></li><li><a href="https://github.com/AloneMonkey/frida-ios-dump">https://github.com/AloneMonkey/frida-ios-dump</a></li><li><a href="https://github.com/stefanesser/dumpdecrypted">https://github.com/stefanesser/dumpdecrypted</a></li><li><a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump">http://www.alonemonkey.com/2018/01/30/frida-ios-dump</a></li><li><a href="https://github.com/rpetrich/CaptainHook/wiki">https://github.com/rpetrich/CaptainHook/wiki</a></li><li><a href="http://iphonedevwiki.net/index.php/Logos">http://iphonedevwiki.net/index.php/Logos</a></li><li><a href="https://github.com/AYJk/AYTikTokPod">https://github.com/AYJk/AYTikTokPod</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;最近接触一款叫 Thor 的软件很好用，类似 Charles 实现手机端抓包软件，可自定义各种规则可以拦截修改请求。网上就出现很多热心朋友分享各种规则规则，通过修改接口开实现破解 App 的效果，接触到一个 TikTok 换区规则激起了我的兴趣。&lt;/p&gt;
&lt;p&gt;看了下规则，大致的原理都是替换请求参数中的 &lt;strong&gt;sys_region&lt;/strong&gt; 与 &lt;strong&gt;carrier_region&lt;/strong&gt;等字段，这种方法虽好，但如果哪天他们开始接口签名校验不就马上不灵了，不如逆向来的稳妥。然后 GitHub 上找到 &lt;a href=&quot;https://github.com/AYJk/AYTikTokPod&quot;&gt;AYTikTokPod&lt;/a&gt;，正好实践下一个 APP 的一个完整逆向过程，于是有了下面的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="MonkeyDev" scheme="https://mryulong.github.io/tags/MonkeyDev/"/>
    
    <category term="逆向" scheme="https://mryulong.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="TikTok" scheme="https://mryulong.github.io/tags/TikTok/"/>
    
  </entry>
  
  <entry>
    <title>ReplayKit 踩坑全记录</title>
    <link href="https://mryulong.github.io/2019/01/09/ReplayKit%20%E8%B8%A9%E5%9D%91%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://mryulong.github.io/2019/01/09/ReplayKit%20%E8%B8%A9%E5%9D%91%E5%85%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2019-01-09T03:08:48.000Z</published>
    <updated>2022-02-09T03:04:08.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，App 有把手机端画面同步到 TV 端的需求，所以才有 ReplayKit 的接入。大致步骤为：手机端视屏采集，数据处理，同步给 TV 端。App 只做了第一步，也就是 ReplayKit 的集成，数据的处理采用了基线提供的 SDK。下面就 ReplayKit 各个系统的主要差异化和遇到的坑做简要的记录。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p><a href="https://developer.apple.com/documentation/replaykit">ReplayKit</a> 是 Apple 提供用于记录屏幕画面和音频的 framework。</p><span id="more"></span><blockquote><p>Using the ReplayKit framework, users can record video from the screen, and audio from the app and microphone. They can then share their recordings with other users through email, messages, and social media. You can build app extensions for live broadcasting your content to sharing services. ReplayKit is incompatible with <a href="https://developer.apple.com/documentation/avfoundation/avplayer"><code>AVPlayer</code></a> content.</p></blockquote><p>下面说说 ReplayKit 一路走来的发展历史。</p><h3 id="iOS-9"><a href="#iOS-9" class="headerlink" title="iOS 9"></a>iOS 9</h3><p>ReplayKit 第一次出现，但是只支持当前 APP 的视屏内容 MP4，然后分享出去，不具备实时性。</p><p>通过下面 API 启动录屏，然后通过 RPPreviewViewController 查看视频，会提供保存和分享功能。同时询问用户权限。如果被拒绝，就无法录制了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RPScreenRecorder</span>.shared().startRecording(withMicrophoneEnabled: <span class="literal">true</span>, handler: ((<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)<span class="operator">?</span>)</span><br></pre></td></tr></table></figure><h3 id="iOS-10"><a href="#iOS-10" class="headerlink" title="iOS 10"></a>iOS 10</h3><p>在 iOS 9 的基础上，增加了视频流实时直播功能，可以直接获取原始音频视频数据。Apple 开放了 Extension App ：broadcast upload extension 和 broadcast setup UI extension。一个负责视频流的上传，一个负责触发页面的显示。当然这个版本已经基本接近现在的版本，可以满足 APP 内视屏画面直播分享。</p><h3 id="iOS-11"><a href="#iOS-11" class="headerlink" title="iOS 11"></a>iOS 11</h3><p>ReplayKit 2 的出现，让录屏不在局限于当前 App，用户可以 Control Center 中的快捷方式，选择录屏应用，然后开始全局的录屏。但是又出现了新的需求：用户只能通过 Control Center 触发，如果放入 APP 中，产品肯定是想要有一个单独的入口和按钮触发开启和关闭按钮。</p><p>增加了新的接口，可以直接启动想要录制的 Extension , 跳过中间选择 sheet 的过程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">load</span>(<span class="title">withPreferredExtension</span> <span class="title">preferredExtension</span>: <span class="title">String</span>?, <span class="title">handler</span>: @<span class="title">escaping</span> (<span class="title">RPBroadcastActivityViewController</span>?, <span class="title">Error</span>?) -&gt; <span class="title">Void</span>)</span></span><br></pre></td></tr></table></figure><h3 id="iOS-12"><a href="#iOS-12" class="headerlink" title="iOS 12"></a>iOS 12</h3><p>ReplayKit 迎来了历史性的时刻，RPSystemBroadcastPickerView 的诞生了，让开发者可以在 APP 中创建，然后启动关闭功能，同时支持 <strong>preferredExtension</strong>来指定录屏的进程，让功能的灵活性有的质的飞跃。</p><h2 id="接入步骤"><a href="#接入步骤" class="headerlink" title="接入步骤"></a>接入步骤</h2><p>接入步骤不在详细解释，官网和全网一堆教程，此处略。</p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="自定义-RPSystemBroadcastPickerView"><a href="#自定义-RPSystemBroadcastPickerView" class="headerlink" title="自定义 RPSystemBroadcastPickerView"></a>自定义 RPSystemBroadcastPickerView</h3><p>可以把 RPSystemBroadcastPickerView 创建外屏幕之外的位置或者自定义按钮下面，然后通过 Block 掉按钮事件，触发 RPSystemBroadcastPickerView 的时间，注意 <strong>UIControl.Event</strong> 是 <strong>.touchDown</strong>， 不是 <strong>.touchUpInside</strong>。大致代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">broadcastPickerViewClickAction</span>()</span>  &#123;</span><br><span class="line">       broadcastPickerView<span class="operator">?</span>.subviews.forEach(&#123; (subView) <span class="keyword">in</span></span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> button <span class="operator">=</span> subView <span class="keyword">as?</span> <span class="type">UIButton</span> &#123;</span><br><span class="line">               button.sendActions(for: .touchDown)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Extension-Crash"><a href="#Extension-Crash" class="headerlink" title="Extension Crash"></a>Extension Crash</h3><p>由于 Apple 对 Extension App 严格的内存大小的限制，一旦超过这个阈值（50M） 就会引起 Crash，这个只能在数据操作和解码方面尽可能的优化，尽量使用 Apple 提供的 VideoToolbox.framework 进行编解码以减少内存的消耗。当然，还可能遇到其他问题，并没有实践过，不做探讨。</p><h3 id="不支持后台直播"><a href="#不支持后台直播" class="headerlink" title="不支持后台直播"></a>不支持后台直播</h3><p>iOS 11 以及以下系统，在 APP 内直接吊起 ReplayKit 都是不支持后台直播的，要想支持从 Control Center 的小圆点启动。iOS 12 是可以通过 RPSystemBroadcastPickerView 实现。</p><h3 id="iOS-11-怎么手动停止录屏"><a href="#iOS-11-怎么手动停止录屏" class="headerlink" title="iOS 11 怎么手动停止录屏"></a>iOS 11 怎么手动停止录屏</h3><p>开始：可以在 <strong>broadcastStartedWithSetupInfo</strong> 中发送开始录屏的进程通知。</p><p>结束：可以主动调用 <strong>finishBroadcastWithError</strong> 终止录屏，但是需要<strong>RPBroadcastSampleHandler</strong> 实例，这里同样需要发送进程通知触发 Extension 中终止方法。</p><h3 id="preferredExtension-不识别"><a href="#preferredExtension-不识别" class="headerlink" title="preferredExtension 不识别"></a>preferredExtension 不识别</h3><p>在开发的过程中，偶现点击 RPSystemBroadcastPickerView 并没有指定的 preferredExtension 的 APP，尚且没有找到解决方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/videos/play/wwdc2016/601/">Go Live with ReplayKit - WWDC 2016</a><br><a href="https://developer.apple.com/documentation/replaykit">ReplayKit</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，App 有把手机端画面同步到 TV 端的需求，所以才有 ReplayKit 的接入。大致步骤为：手机端视屏采集，数据处理，同步给 TV 端。App 只做了第一步，也就是 ReplayKit 的集成，数据的处理采用了基线提供的 SDK。下面就 ReplayKit 各个系统的主要差异化和遇到的坑做简要的记录。&lt;/p&gt;
&lt;h2 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/replaykit&quot;&gt;ReplayKit&lt;/a&gt; 是 Apple 提供用于记录屏幕画面和音频的 framework。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="ReplayKit" scheme="https://mryulong.github.io/tags/ReplayKit/"/>
    
    <category term="踩坑" scheme="https://mryulong.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>2018年个人总结</title>
    <link href="https://mryulong.github.io/2019/01/01/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://mryulong.github.io/2019/01/01/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2019-01-01T02:34:40.000Z</published>
    <updated>2022-02-09T03:04:38.157Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/01/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/IMG_2203.jpg"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>时间很快，2018 年匆匆而过，迎来 2019 年。下面从工作、学习、生活三个方面说说我的 2018，展望已经到来的 2019。</p><h2 id="过去的-2018"><a href="#过去的-2018" class="headerlink" title="过去的 2018"></a>过去的 2018</h2><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>这一年最大变化应该是：工作方面。离开了工作了两年三个月的平安，入职爱奇艺。两家公司，从龙华到淞虹路，从安逸到忙碌。截然不同的两家公司，给了我不一样的工作体验。</p><span id="more"></span><p>电视果对比好房更偏向于对接硬件，对蓝牙、长链接、JS 脚本都有涉及，而这些都是我以前接触很少的东西，有压力也很有动力，目前很多业务我还在熟练中，也已经渐渐的融入了紧张忙碌的节奏，希望以后有更多的收获。</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><h4 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h4><p>两家公司让我对技术架构、组件化、Hybrid、自动化，都有了一定的认识，但是目前还是缺乏深入的研究和实践。</p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p>翻了一下 2018 的读书记录，这一年读书寥寥无几，实在惭愧。</p><ul><li>马伯庸 《笑翻中国简史》，书中以五行学说、帝王德行串联起各个王朝，读起来更具趣味性。</li><li>徐中约 《中国近代史》，从清末到建国，近代历史的发展，详细而公正。</li><li>矫健 《天局》，这个存粹慕名去看的，书中自己做棋子，“胜天半子” 确实大气。</li><li>《The Swift Programming Language 中文版》</li><li>《Effective Objective-C 2.0》》</li><li>《图解 HTTP 彩色版》</li><li>《iOS 与 OS X 多线程和内存管理》</li><li>《Swifter 100 个 swift 必备的 tips》</li></ul><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p>年中的时候搭了博客，后来逐渐懈怠了，再加上工作的变化，停了很久一段时间，纵观现存的几篇文章，内容缺乏深度和质量，后续需要正确对待，保持梳理总结。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><h4 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h4><p>今年开始进入股市，无奈赶上贸易战，整体亏损达到了百分之二十，当然亏钱也不单单是因为贸易战，心态是决定成败的关键，一旦看到数字跳动就心惊肉跳，赶紧卖或者赶紧买，忽略了仓位风险控制和大盘趋势分析，这样亏损也是在所难免的。</p><h4 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h4><p>今年入手一把吉他雅马哈的 FG800M 非常喜欢，也算是满足少年时候的梦想，拿到之后我发现我可能真心不适合弹吉他，F 和弦直接秒杀了我，但是本着四字真言：“买都买了”，依旧坚持下来，终于算是征服了 F 和弦，可是后来发现这只是开始，不过我还是会坚持下去。这样单纯代码也能有些文艺气息进来的，丰富时光。</p><h4 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h4><p>最近两年的体检总是轻度脂肪肝，让我开始关注自己的体重，前半年开始去健身房，有氧运动为主，后面做 Insanity 60，每天晚上下班回家做，心跳一度飙升到 200，坚持一个月后放弃，最终保守估计瘦了 8 kg，最近加班多了，主要还是以控制饮食来减肥，收效甚微。</p><h2 id="崭新的-2019"><a href="#崭新的-2019" class="headerlink" title="崭新的 2019"></a>崭新的 2019</h2><p>新年希望一切都有新气象，有一个全新的开始，在这里我也想立一些 flag:</p><ul><li>读书，充分利用长通勤时间，读完当前为读完的，扩展其他方面，理财、历史、效率方面。</li><li>技术，完全熟悉当前公司业务代码逻辑。</li><li>写作，每月保持一到两片的博客，保证高质量，不做摘抄。</li><li>管理自己的情绪，提高情商。</li><li>吉他，坚持学吉他。</li><li>减肥健身，关注健康，体重减少 20 斤，体脂降低 5%。</li><li>旅行，希望出一次远门。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2018 是安逸的，2019 是奋起的一年，不断增强自己的软实力，增加技术的深度和广度，同时更加关注身体健康，总之，2019，加油！ 遇见更好的自己。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2019/01/01/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/IMG_2203.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;时间很快，2018 年匆匆而过，迎来 2019 年。下面从工作、学习、生活三个方面说说我的 2018，展望已经到来的 2019。&lt;/p&gt;
&lt;h2 id=&quot;过去的-2018&quot;&gt;&lt;a href=&quot;#过去的-2018&quot; class=&quot;headerlink&quot; title=&quot;过去的 2018&quot;&gt;&lt;/a&gt;过去的 2018&lt;/h2&gt;&lt;h3 id=&quot;关于工作&quot;&gt;&lt;a href=&quot;#关于工作&quot; class=&quot;headerlink&quot; title=&quot;关于工作&quot;&gt;&lt;/a&gt;关于工作&lt;/h3&gt;&lt;p&gt;这一年最大变化应该是：工作方面。离开了工作了两年三个月的平安，入职爱奇艺。两家公司，从龙华到淞虹路，从安逸到忙碌。截然不同的两家公司，给了我不一样的工作体验。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://mryulong.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="年末总结" scheme="https://mryulong.github.io/tags/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode算法刷题记录（持续更新...）</title>
    <link href="https://mryulong.github.io/2018/09/21/LeetCode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/"/>
    <id>https://mryulong.github.io/2018/09/21/LeetCode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/</id>
    <published>2018-09-21T02:14:31.000Z</published>
    <updated>2022-02-09T03:03:57.666Z</updated>
    
    <content type="html"><![CDATA[<p>本文持续更新 LeetCode 算法题目探索分析和揭发，保留原题目描述和编号以便复查。</p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><span id="more"></span><p>分析：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文持续更新 LeetCode 算法题目探索分析和揭发，保留原题目描述和编号以便复查。&lt;/p&gt;
&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的&lt;strong&gt;两个&lt;/strong&gt;数。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以返回 [0, 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://mryulong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://mryulong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://mryulong.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>面试复盘</title>
    <link href="https://mryulong.github.io/2018/08/24/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
    <id>https://mryulong.github.io/2018/08/24/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</id>
    <published>2018-08-24T03:20:01.000Z</published>
    <updated>2022-02-09T03:04:41.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h3><h4 id="为什么要离职"><a href="#为什么要离职" class="headerlink" title="为什么要离职"></a>为什么要离职</h4><h4 id="最近在读什么技术书籍"><a href="#最近在读什么技术书籍" class="headerlink" title="最近在读什么技术书籍"></a>最近在读什么技术书籍</h4><h3 id="Object-C-Swift"><a href="#Object-C-Swift" class="headerlink" title="Object-C / Swift"></a>Object-C / Swift</h3><h4 id="OC-类-load-方法，子类和父类哪个先执行"><a href="#OC-类-load-方法，子类和父类哪个先执行" class="headerlink" title="OC 类+load 方法，子类和父类哪个先执行"></a>OC 类+load 方法，子类和父类哪个先执行</h4><span id="more"></span><table><thead><tr><th></th><th>+load</th><th>+initialize</th></tr></thead><tbody><tr><td>调用时机</td><td>被添加到 runtime 时</td><td>到第一条消息前，可能永远不调用</td></tr><tr><td>同一个类，调用次数 （不考虑主动调用）</td><td>1 次</td><td>1 次</td></tr><tr><td>调用顺序</td><td>父类-&gt;本类-&gt;分类</td><td>父类-&gt;本类(如果有分类，则调用分类)</td></tr><tr><td>若自身未实现，是否沿用父类的方法？</td><td>否</td><td>是</td></tr><tr><td>类别中的定义</td><td>全都执行，但后于本类的方法</td><td>覆盖本类的方法，只执行一个</td></tr><tr><td>线程安全</td><td>安全</td><td>安全</td></tr></tbody></table><p>如果子类未实现+initialize 方法，会沿用父类的，这样会造成父类的+initialize 方法被多次调用，相比+load 就则不会沿用。+initialize 走的是 msgSend 流程，若类未收到消息一直不会被调用，+load 是在 Runtime 阶段调用。</p><h4 id="OC-中-Category-和-Extensio-的区别，Category-能否添加属性"><a href="#OC-中-Category-和-Extensio-的区别，Category-能否添加属性" class="headerlink" title="OC 中 Category 和 Extensio 的区别，Category 能否添加属性"></a>OC 中 Category 和 Extensio 的区别，Category 能否添加属性</h4><p>1、Extension 是类的一部分，编译器就被加载，Category 在 Runtime 阶段载入，独立于类之外</p><p>2、Extension 用于私有化属性和方法，仅有声明，Category 包括声明和实现，分散功能的实现，让业务更加清晰。</p><p>可以添加属性 objc_setAssociatedObject、objc_getAssociatedObject 重写 set/get 方法，且支持 KVO</p><h4 id="属性修饰关键词，如果对外只读，-m-可以修改怎么办？如果想-self-pro-来修改怎么办？"><a href="#属性修饰关键词，如果对外只读，-m-可以修改怎么办？如果想-self-pro-来修改怎么办？" class="headerlink" title="属性修饰关键词，如果对外只读，.m 可以修改怎么办？如果想 self.pro 来修改怎么办？"></a>属性修饰关键词，如果对外只读，.m 可以修改怎么办？如果想 self.pro 来修改怎么办？</h4><p>不能修改，需要_key 的方法来修改变量值，同时也可以通过 KVO 来修改。当使用 <code>setValue:forKey:</code> 来设置对象的属性时，会以下面的优先顺序来寻找对应的 <code>key</code>：</p><ol><li>消息接收对象会查找是否存在满足 <code>set&lt;Key&gt;:</code> 格式的存取方法。</li><li>如果不存在满足条件的存取方法，且消息接收对象的类方法 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回 YES，那么该对象会以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找是否存在对应的 key。当然 <code>+ (BOOL)accessInstanceVariablesDirectly</code>返回 NO，便可以阻止 KVO 修改变量。</li><li>如果存在对应的存取方法或者找到对应的实例变量，那么就会改变该 key 所对应的值 value。</li><li>如果没有找到对应的存取方法或者实例变量，那么该消息对象的 <code>setValue:forUndefinedKey:</code> 将会调用。</li></ol><h4 id="copy-修饰可变-MutableArray-会怎么样"><a href="#copy-修饰可变-MutableArray-会怎么样" class="headerlink" title="copy 修饰可变 MutableArray 会怎么样"></a>copy 修饰可变 MutableArray 会怎么样</h4><p>对数组进行可变操作时候回造成 crash</p><h4 id="是否用-Swift-开发，熟悉程度，protocol-在-swift-和-OC-里的却别"><a href="#是否用-Swift-开发，熟悉程度，protocol-在-swift-和-OC-里的却别" class="headerlink" title="是否用 Swift 开发，熟悉程度，protocol 在 swift 和 OC 里的却别"></a>是否用 Swift 开发，熟悉程度，protocol 在 swift 和 OC 里的却别</h4><p>1.OC 中的协议只能用于类,swift 中的协议不仅能用于类,还能用于结构体和枚举<br>2.OC 中的协议可以设置可选实现,但 Swift 中的协议必须实现<br>3.Swift 中的协议增加了一个关键字 mutating 可以决定结构体和枚举实现协议的时候,是否可以修改属性的值</p><h4 id="Swift-结构体里的方法如何重写"><a href="#Swift-结构体里的方法如何重写" class="headerlink" title="Swift 结构体里的方法如何重写"></a>Swift 结构体里的方法如何重写</h4><h4 id="Swift-几大关键字的区别-fileprivate、open-、private、public、internal"><a href="#Swift-几大关键字的区别-fileprivate、open-、private、public、internal" class="headerlink" title="Swift 几大关键字的区别 fileprivate、open 、private、public、internal"></a>Swift 几大关键字的区别 fileprivate、open 、private、public、internal</h4><p>1、private<br>private 访问级别所修饰的属性或者方法只能在当前类里访问。</p><p>2、fileprivate<br>fileprivate 访问级别所修饰的属性或者方法在当前的 Swift 源文件里可以访问。</p><p>3、internal（默认访问级别，internal 修饰符可写可不写）<br>internal 访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。<br>如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。<br>如果是 App 代码，也是在整个 App 代码，也是在整个 App 内部可以访问。</p><p>4、public<br>可以被任何人访问。但其他 module 中不可以被 override 和继承，而在 module 内可以被 override 和继承。</p><p>5，open<br>可以被任何人使用，包括 override 和继承。</p><p>访问顺序：<br>现在的访问权限则依次为：open，public，internal，fileprivate，private。</p><h4 id="Swift-里做方法交换，如何实现"><a href="#Swift-里做方法交换，如何实现" class="headerlink" title="Swift 里做方法交换，如何实现"></a>Swift 里做方法交换，如何实现</h4><p>Swift 方法交换</p><p>swift4.0 中 initialize 和 load 都相继废除了，applicationDidFinishLaunching 方法中，检测所有注册的类，是否实现了提前声明的协议，如果实现了协议方法，则调起协议方法，在此方法中，实现 method swizzling</p><p><a href="http://blog.yaoli.site/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8Swift4%E4%B8%AD%E5%AE%9E%E7%8E%B0Method-Swizzling">如何优雅地在 Swift4 中实现 Method-Swizzling</a></p><h4 id="数据库用的什么，plist-内存加载性能损耗问题，coredata-缺点"><a href="#数据库用的什么，plist-内存加载性能损耗问题，coredata-缺点" class="headerlink" title="数据库用的什么，plist 内存加载性能损耗问题，coredata 缺点"></a>数据库用的什么，plist 内存加载性能损耗问题，coredata 缺点</h4><p>FMDB、plist、CoreData</p><p>plist 的读取是整体全部读入内存，如果频繁需要修改的数据，不建议用此方法，可以考虑 FMDB、CoreData</p><p>CoreData,建立的表没有主键，添加时都要自己处理。它不是关系型数据库，处理多对多的关系时比较麻烦。</p><p>CoreData 的一个比较大的痛点是多人合作开发的时候，管理 CoreData 的模型需要很小心，尤其是合并的时候，他的 data model 是 XML 格式的，手动 resolve 比较烦。</p><p>CoreData 自定义升级麻烦,并且效率非常低下,升级的版本变动很难跟踪。</p><h4 id="lru-算法"><a href="#lru-算法" class="headerlink" title="lru 算法"></a>lru 算法</h4><p>lru</p><p>多用于链表缓存数据，新插入表头的数据，如果缓存命中则把数据取到表头，链表满的时候，优先删除链表尾部的数据。存在热点数据情况该算法很好用，但是如果有周期性或者偶发性任务，会导致缓存污染。</p><p>lru-k</p><ol><li><p>数据第一次被访问，加入到访问历史列表；</p></li><li><p>如果数据在访问历史列表里后没有达到 K 次访问，则按照一定规则（FIFO，LRU）淘汰；</p></li><li><p>当访问历史队列中的数据访问次数达到 K 次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p></li><li><p>缓存数据队列中被再次访问后，重新排序；</p></li><li><p>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第 K 次访问离现在最久”的数据。</p></li></ol><p>LRU-K 具有 LRU 的优点，同时能够避免 LRU 的缺点，实际应用中 LRU-2 是综合各种因素后最优的选择，LRU-3 或者更大的 K 值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉</p><h4 id="AF-SD-的源码是否有读过，SD-的-downloadOpera-为什么是重写-start-方法，而不是-main-方法，区别在哪里。AF-里面为什么要定义一个-Runloop"><a href="#AF-SD-的源码是否有读过，SD-的-downloadOpera-为什么是重写-start-方法，而不是-main-方法，区别在哪里。AF-里面为什么要定义一个-Runloop" class="headerlink" title="AF SD 的源码是否有读过，SD 的 downloadOpera 为什么是重写 start 方法，而不是 main 方法，区别在哪里。AF 里面为什么要定义一个 Runloop"></a>AF SD 的源码是否有读过，SD 的 downloadOpera 为什么是重写 start 方法，而不是 main 方法，区别在哪里。AF 里面为什么要定义一个 Runloop</h4><p>重写<code>main</code>方法比较简单，我们不需要管理操作的状态属性 <code>isExecuting</code> 和 <code>isFinished</code>。当 <code>main</code> 执行完返回的时候，这个操作就结束了。而 SD 中的操作可能有一些异步的操作并没有完成，需要手动管理线程执行状态，所以重写了<code>start</code>方法而非<code>main</code>方法。</p><p>AF 2.x 定义 Runloop，为了保证 NSURLConnection 可以在网络发出线程接受回调，故需要 Runloop 保持线程存活状态。</p><p>AF 3.x 采用了 NSURLSession，每个 NSURLSessionTask 绑定一个 AFURLSessionManagerTaskDelegate，这个 TaskDelegate 相当于把 NSURLSessionDelegate 进行了一层过滤，最终只保留类似 didCompleteWithError 这样对上层调用者输出的回调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 此处设置并发数为1，是为了保证数据处理串行回调</span><br><span class="line">// 回调内部有一个NSLock，对 self.mutableTaskDelegatesKeyedByTaskIdentifier 的访问进行了加锁，目的保证多线程下数据的安全</span><br><span class="line">self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure><h4 id="内存泄漏使用的什么检测工具"><a href="#内存泄漏使用的什么检测工具" class="headerlink" title="内存泄漏使用的什么检测工具"></a>内存泄漏使用的什么检测工具</h4><p>Xcode 自带的 Instruments 中的 leaks</p><p>FB 开源的 FBRetainCycleDetector 静态库</p><h4 id="iOS-有哪几种锁，各自的效率高低"><a href="#iOS-有哪几种锁，各自的效率高低" class="headerlink" title="iOS 有哪几种锁，各自的效率高低"></a>iOS 有哪几种锁，各自的效率高低</h4><p><a href="https://www.jianshu.com/p/7e9dd2cb78a8">iOS 十种线程锁</a></p><p><a href="https://blog.csdn.net/qq_35247219/article/details/51930849"> 多线程的几种加锁方式详解</a></p><h4 id="tableview-和-collectionView-区别"><a href="#tableview-和-collectionView-区别" class="headerlink" title="tableview 和 collectionView 区别"></a>tableview 和 collectionView 区别</h4><p>首先二者准守协议是不一样的，其次就 cell 的注册，后者必须声明注册而前者则非必须。前者更适用于一行一行的列表展示形式，而后者相对来说要灵活许多不限于这一种，可以自定义 flowlayout 实现许多负责的 cell 排列以及动画。</p><h4 id="delegate-和-Block-的区别"><a href="#delegate-和-Block-的区别" class="headerlink" title="delegate 和 Block 的区别"></a>delegate 和 Block 的区别</h4><p>相同点：两者都是函数回调作用</p><p>不同点：</p><ol><li> Block 是一个轻量级的，可以让声明和实现在一块，保持了代码的连贯性，而 delegate 则赋值和实现是分开的</li><li> delegate 值是单纯的指针引用，回调时候为函数消息调用过程，block 相对之下更加复杂，会引用上下文，容易造成循环引用，要维护引用计数、自身由栈到堆的拷贝，故前者资源损坏要小于后者。</li><li> 超过三个回调，delegate 可以通过多个代理方法实现，block 需要多次赋值实现，前者更简单，故超过三个回调建议使用 delegate</li></ol><h5 id="block-的分类："><a href="#block-的分类：" class="headerlink" title="block 的分类："></a>block 的分类：</h5><p>全局静态 block：不会访问任何外部变量，执行完就销毁</p><p>保存在栈中的 block：调用了外部变量，当函数返回时候被销毁</p><p>堆中的 block：当引用计数为 0 时候被销毁，被类强引用，copy 修饰的 block</p><table><thead><tr><th>block 在哪</th><th>捕获变量</th><th>ARC</th><th>非 arc</th></tr></thead><tbody><tr><td>copy</td><td>是</td><td>heap</td><td>heap</td></tr><tr><td>no copy</td><td>是</td><td>heap</td><td>stack</td></tr><tr><td>copy</td><td>否</td><td>global</td><td>global</td></tr><tr><td>no copy</td><td>否</td><td>global</td><td>global</td></tr></tbody></table><h4 id="Crash-捕捉是否是自己实现的，去过启动就发生-crash，如何捕捉"><a href="#Crash-捕捉是否是自己实现的，去过启动就发生-crash，如何捕捉" class="headerlink" title="Crash 捕捉是否是自己实现的，去过启动就发生 crash，如何捕捉"></a>Crash 捕捉是否是自己实现的，去过启动就发生 crash，如何捕捉</h4><p><a href="https://blog.csdn.net/qq_40201300/article/details/79894533">连续崩溃解决方案</a></p><h4 id="是否做单元测试、UI-测试"><a href="#是否做单元测试、UI-测试" class="headerlink" title="是否做单元测试、UI 测试"></a>是否做单元测试、UI 测试</h4><p>没有</p><h4 id="使用过什么-Json-解析库，Model-转换工具、"><a href="#使用过什么-Json-解析库，Model-转换工具、" class="headerlink" title="使用过什么 Json 解析库，Model 转换工具、"></a>使用过什么 Json 解析库，Model 转换工具、</h4><p>目前项目中使用的 YYModel</p><p><a href="https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/">JSON 模型转换库评测</a></p><h4 id="除了-Autolayout-是否还接触过跨平台的-Yoga-布局"><a href="#除了-Autolayout-是否还接触过跨平台的-Yoga-布局" class="headerlink" title="除了 Autolayout 是否还接触过跨平台的 Yoga 布局"></a>除了 Autolayout 是否还接触过跨平台的 Yoga 布局</h4><p><a href="https://www.jianshu.com/p/d4289b16a133">Yoga 布局</a></p><h4 id="C-请求依赖-A-、B-请求完成如何做，GCD-怎么做，不用-GCD-怎么做，operation-是否能添加多个依赖"><a href="#C-请求依赖-A-、B-请求完成如何做，GCD-怎么做，不用-GCD-怎么做，operation-是否能添加多个依赖" class="headerlink" title="C 请求依赖 A 、B 请求完成如何做，GCD 怎么做，不用 GCD 怎么做，operation 是否能添加多个依赖"></a>C 请求依赖 A 、B 请求完成如何做，GCD 怎么做，不用 GCD 怎么做，operation 是否能添加多个依赖</h4><p>1、信号量，而且能做到多个任务串行执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">[网络请求:&#123;</span><br><span class="line">        成功：dispatch_semaphore_signal(sema);</span><br><span class="line">        失败：dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure><p>2、group</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();    dispatch_group_enter(group);</span><br><span class="line"></span><br><span class="line">// 网络成功/失败</span><br><span class="line">  dispatch_group_leave(group);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>NSOperation 添加依赖不能解决异步依赖问题，请求发出后即认为任务完成，所以并不能达到效果。</p><h4 id="Runloop-的-model-是否了解过，UITrackingRunLoopMode-和-NSRunLoopCommonModes-哪个优先级更强"><a href="#Runloop-的-model-是否了解过，UITrackingRunLoopMode-和-NSRunLoopCommonModes-哪个优先级更强" class="headerlink" title="Runloop 的 model 是否了解过，UITrackingRunLoopMode 和 NSRunLoopCommonModes 哪个优先级更强"></a>Runloop 的 model 是否了解过，UITrackingRunLoopMode 和 NSRunLoopCommonModes 哪个优先级更强</h4><blockquote><ul><li>kCFRunLoopDefaultMode, App 的默认运行模式，通常主线程是在这个运行模式下运行</li><li>UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响）</li><li>kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式</li><li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li><li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li></ul></blockquote><p>NSRunLoopCommonModes 只是一种占位模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式.</p><h4 id="多次对同一个方法-method-swizzing，会有什么问题"><a href="#多次对同一个方法-method-swizzing，会有什么问题" class="headerlink" title="多次对同一个方法 method swizzing，会有什么问题"></a>多次对同一个方法 method swizzing，会有什么问题</h4><p>一份 method swizzing 代码多次执行，会反复交换 IMP，可能达不到预期效果</p><p>多个类对同一方法替换，则不会有问题</p><h5 id="method-swizzing-的两种写法讨论"><a href="#method-swizzing-的两种写法讨论" class="headerlink" title="method swizzing 的两种写法讨论"></a>method swizzing 的两种写法讨论</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 第一种写法</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL s1 = @selector(go);</span><br><span class="line">        SEL s2 = @selector(stop);</span><br><span class="line">        Class class = object_getClass((id)self);</span><br><span class="line">        Method m1 = class_getClassMethod(class, s1);</span><br><span class="line">        Method m2 = class_getClassMethod(class, s2);</span><br><span class="line">        BOOL success = class_addMethod(class, s1, method_getImplementation(m2), method_getTypeEncoding(m2));</span><br><span class="line">        if (success)&#123;</span><br><span class="line">            class_replaceMethod(class, s2, method_getImplementation(m1), method_getTypeEncoding(m1));</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            method_exchangeImplementations(m1, m2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 第二种写法</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL s1 = @selector(go);</span><br><span class="line">        SEL s2 = @selector(stop);</span><br><span class="line">        Class class = object_getClass((id)self);</span><br><span class="line">        Method m1 = class_getClassMethod(class, s1);</span><br><span class="line">        Method m2 = class_getClassMethod(class, s2);</span><br><span class="line">        method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者写法差别在于替换之前是否进行 class_addMethod 判断，第一种是比较严谨的写法；而第二种，当我们想交换有多个继承关系的子类里面的方法并且子类没有实现父类的方法时，直接 method_exchangeImplementations 会把父类的方法也给交换了。</p><blockquote><p><code>class_addMethod</code>函数会检查方法有没有实现，如果已经实现会返回 NO ，也就是直接走<code>method_exchangeImplementations</code>方法；没有实现会先在当前类增加一个新的实现方法，再把目标类中的方法通过<code>class_replaceMethod</code>函数替换为旧有的实现。</p></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="源码管理，终端还是客户端，使用过-cherry-pick-指定没"><a href="#源码管理，终端还是客户端，使用过-cherry-pick-指定没" class="headerlink" title="源码管理，终端还是客户端，使用过 cherry-pick 指定没"></a>源码管理，终端还是客户端，使用过 cherry-pick 指定没</h4><p>混合使用，cherry-pick 的作用是把一个分支的 commit，复制到另一个分支上去。支持复制多个，如果连续可用’..’链接，但是不包括起始的 commitID，如果是不连续多个则直接空格分隔即可</p><h4 id="git-rebase-和-git-stash-使用、作用"><a href="#git-rebase-和-git-stash-使用、作用" class="headerlink" title="git rebase 和 git stash 使用、作用"></a>git rebase 和 git stash 使用、作用</h4><p>git rebase 功能同 merge，rebase 会重整时间线，看上去更加简洁，</p><p>git stash 暂存代码</p><h4 id="删除分支或者-tag-指令"><a href="#删除分支或者-tag-指令" class="headerlink" title="删除分支或者 tag 指令"></a>删除分支或者 tag 指令</h4><p>git branch -D <branch name></p><p>git push origin -delete <branch name></p><p>git push origin :<branch name></p><h3 id="Http-Https"><a href="#Http-Https" class="headerlink" title="Http/Https"></a>Http/Https</h3><h4 id="Https-传输加密的方法，对称加密还是非对称加密"><a href="#Https-传输加密的方法，对称加密还是非对称加密" class="headerlink" title="Https 传输加密的方法，对称加密还是非对称加密?"></a>Https 传输加密的方法，对称加密还是非对称加密?</h4><p>非对称加密仅在握手阶段，传输过程中采用对称加密，原因是对称加密的效率要高于非对称。</p><h4 id="HTPPS-大致传输过程"><a href="#HTPPS-大致传输过程" class="headerlink" title="HTPPS 大致传输过程"></a>HTPPS 大致传输过程</h4><ol><li><p>客户端发送 HTTPS 请求，附带自己的加密算法和 TLC/SSL 版本；</p></li><li><p>服务端接收到请求，发送自己的证书给客户端;</p><blockquote><p>证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等；</p></blockquote></li><li><p>客户端收到证书校验证书合法性，如果合法，生成一个随机数，然后使用公钥对随机数加密（当然这个随机数，就是以后数据传输的对称加密的秘钥），同时使用该秘钥对消息进行加密；</p><blockquote><p>一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。当然客户端也可以信任不合法的证书。</p></blockquote></li><li><p>服务端拿到这个随机数，用私钥解密，得到客户端随机生成的序列号，用此序列号加密消息，对比客户端发来是否一致，校验消息是否被篡改；通过后，加密一段握手消息，同时附带消息加密值，发送给客户端；</p></li><li><p>客户端，拿到消息后，同样首先校验消息完整性，然后检查消息是否为握手消息；</p></li><li><p>握手结束后，客户端和服务端使用在握手阶段生成说的随机数以及挑选出的算法进行对称加密传输。</p></li></ol><h4 id="经常使用的加密算法"><a href="#经常使用的加密算法" class="headerlink" title="经常使用的加密算法"></a>经常使用的加密算法</h4><ol><li>非对称加密算法：RSA, DSA/DSS</li><li>对称加密算法： AES, 3DES</li><li>HASH 算法：MD5, SHA1, SHA256</li></ol><h3 id="组件化相关"><a href="#组件化相关" class="headerlink" title="组件化相关"></a>组件化相关</h3><h4 id="组件化是如何做的，不同模块之间的通信方式"><a href="#组件化是如何做的，不同模块之间的通信方式" class="headerlink" title="组件化是如何做的，不同模块之间的通信方式"></a>组件化是如何做的，不同模块之间的通信方式</h4><p>现在项目，组件之间的通信还是通过 URL 注册维护本地 plist，然后 Router 模块完成调度。</p><h4 id="URL-的方式路由，有什么优化方案，注册的时机是什么？load-方法中注册，耗时如何优化启动时间"><a href="#URL-的方式路由，有什么优化方案，注册的时机是什么？load-方法中注册，耗时如何优化启动时间" class="headerlink" title="URL 的方式路由，有什么优化方案，注册的时机是什么？load 方法中注册，耗时如何优化启动时间"></a>URL 的方式路由，有什么优化方案，注册的时机是什么？load 方法中注册，耗时如何优化启动时间</h4><p>项目会维护一个装有所有界面信息的 plist 表，在 load 方法中，统一加载入内存，通过 Router 方案完成界面跳转和通信。</p><p>优化方案：plist 加载会影响启动时间，是否可以通过 Runtime 的方式，在运行时，把所有的模块信息加载入内存，不做本地的持久化维护和读取，同样也节省了后续页面信息的维护成本。</p><h4 id="除了-Router-的方式，是否还尝试过其他方式的组件化方案"><a href="#除了-Router-的方式，是否还尝试过其他方式的组件化方案" class="headerlink" title="除了 Router 的方式，是否还尝试过其他方式的组件化方案"></a>除了 Router 的方式，是否还尝试过其他方式的组件化方案</h4><p>具体并没有尝试过，有了解过一下几种：</p><ol><li>蘑菇街方案：通过 ModuleManager 来管理所有的 Module URL，调用的时候，传递到 ModuleManager，然后类似 openURL 的形式完成调度。</li><li>case Mediator 方案：通过 target-action 的方式解耦组件和业务方之间的业务，组件持有一个 target 的类，用来初始化组件中的内容，这一块对业务方是无感知的，业务方依赖另一个 Mediator 的 Category 的 repo，调用组件里内容。<a href="https://casatwy.com/iOS-Modulization.html">CTMediator</a></li><li>BeeHive 方案：暂未详细了解。</li></ol><h4 id="阿里的-BeeHive-是否了解过"><a href="#阿里的-BeeHive-是否了解过" class="headerlink" title="阿里的 BeeHive 是否了解过"></a>阿里的 BeeHive 是否了解过</h4><p>没有</p><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><h4 id="Hybird、RN、Weex-有尝试过"><a href="#Hybird、RN、Weex-有尝试过" class="headerlink" title="Hybird、RN、Weex 有尝试过"></a>Hybird、RN、Weex 有尝试过</h4><p>并没有尝试过，但都做了了解。分析三种方案的优缺点。</p><h4 id="热修复-JSPatch-原理，在哪个时间点替换的-，如何拿到拿到方法以及参数"><a href="#热修复-JSPatch-原理，在哪个时间点替换的-，如何拿到拿到方法以及参数" class="headerlink" title="热修复 JSPatch 原理，在哪个时间点替换的 ，如何拿到拿到方法以及参数"></a>热修复 JSPatch 原理，在哪个时间点替换的 ，如何拿到拿到方法以及参数</h4><p>当 app 启动，加载 JSEngine 时，会加载下发的 JS 文件，根据文件中所指定的类和方法名，可以在类的 method_list 中找到对应的方法和参数，然后替换对应的方法，这里它并没有直接替换 IMP 指针，而是把触发延迟到消息转发，这样通过 NSInvocation 拿到调用的所有参数值，通过 JavaScriptCore 执行 JS 中的方法。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="找出-2-个单链表的交点"><a href="#找出-2-个单链表的交点" class="headerlink" title="找出 2 个单链表的交点"></a>找出 2 个单链表的交点</h4><h4 id="二叉树翻转"><a href="#二叉树翻转" class="headerlink" title="二叉树翻转"></a>二叉树翻转</h4>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;闲谈&quot;&gt;&lt;a href=&quot;#闲谈&quot; class=&quot;headerlink&quot; title=&quot;闲谈&quot;&gt;&lt;/a&gt;闲谈&lt;/h3&gt;&lt;h4 id=&quot;为什么要离职&quot;&gt;&lt;a href=&quot;#为什么要离职&quot; class=&quot;headerlink&quot; title=&quot;为什么要离职&quot;&gt;&lt;/a&gt;为什么要离职&lt;/h4&gt;&lt;h4 id=&quot;最近在读什么技术书籍&quot;&gt;&lt;a href=&quot;#最近在读什么技术书籍&quot; class=&quot;headerlink&quot; title=&quot;最近在读什么技术书籍&quot;&gt;&lt;/a&gt;最近在读什么技术书籍&lt;/h4&gt;&lt;h3 id=&quot;Object-C-Swift&quot;&gt;&lt;a href=&quot;#Object-C-Swift&quot; class=&quot;headerlink&quot; title=&quot;Object-C / Swift&quot;&gt;&lt;/a&gt;Object-C / Swift&lt;/h3&gt;&lt;h4 id=&quot;OC-类-load-方法，子类和父类哪个先执行&quot;&gt;&lt;a href=&quot;#OC-类-load-方法，子类和父类哪个先执行&quot; class=&quot;headerlink&quot; title=&quot;OC 类+load 方法，子类和父类哪个先执行&quot;&gt;&lt;/a&gt;OC 类+load 方法，子类和父类哪个先执行&lt;/h4&gt;</summary>
    
    
    
    <category term="面试" scheme="https://mryulong.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://mryulong.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>WebP初探和实践</title>
    <link href="https://mryulong.github.io/2018/07/23/WebP%E5%88%9D%E6%8E%A2%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>https://mryulong.github.io/2018/07/23/WebP%E5%88%9D%E6%8E%A2%E5%92%8C%E5%AE%9E%E8%B7%B5/</id>
    <published>2018-07-23T08:20:57.000Z</published>
    <updated>2022-02-09T03:04:56.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebP（发音 weppy，<a href="https://developers.google.com/speed/webp/">项目主页</a>），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的  WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。<br><img src="http://upload-images.jianshu.io/upload_images/910527-557d9a3e234240e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各个压缩比下WebP和PNG的体积对比"></p><span id="more"></span><p>更详细对比的可以<a href="https://isparta.github.io/compare-webp/index.html#12345">查看</a>这里。</p><p>除了 WebP 在解码时间与 PNG 有较明显差异（毫秒级别，WebP 的解码时间是 PNG 的 5 倍 左右）之外，总体使用体验和 PNG 基本无差异。同时也需要明确，移动设备的发展迅猛，硬件升级快，上一年的表现也许在今年又有了明显的提升。所以，在 App 中使用 WebP 基本没有技术阻碍。</p><h2 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h2><p>官方对于每一种 WebP 格式也分别提供了对应的  <a href="https://developers.google.com/speed/webp/download">转换工具</a>，主要包含了 cwebp、dwebp、vwebp、webpmux、gif2webp 等几种，开发者可以择优选择。另外，还有一些可视化软件来完成转换，如：<a href="http://isparta.github.io/">iSparta</a> 、<a href="http://zhitu.isux.us/">智图</a>。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>WebP 的主要还是给网络传输一种更轻量级的传输方案，可以应用于图片较多的 Web 页面、IM 中图片发送等。对于本地图片或者网络图片，都可以有不错的实践。</p><h3 id="本地-WebP-资源"><a href="#本地-WebP-资源" class="headerlink" title="本地 WebP 资源"></a>本地 WebP 资源</h3><p>经手过一个项目把本地图片替换成 WebP，这样可以达到瘦包的效果。但其实对于后资源的管理并不如放到<strong>Assets.xcassets</strong>里面方便。大致的实现原理：通过 Category 添加方法<code>pa_imageNamed:</code>，runtime 交换<strong>UIImage</strong>的<code>imageNamed:</code>方法，然后根据图片名称拼接完整 Path，转化成 Data，利用<strong>SDWebImag</strong>的<code>sd_imageWithWebPData:</code>变为可识别的图片格式直接给控件调用。由于开发项目中有用到，所以有写过一个工具（<a href="https://github.com/MrYulong/WebPTest">源码</a>），主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">///替换系统方法</span><br><span class="line">Method imageNamed          = class_getClassMethod([UIImage class], @selector(imageNamed:));</span><br><span class="line">Method webImageNamed   = class_getClassMethod([UIImage class], @selector(pa_imageNamed:));</span><br><span class="line">method_exchangeImplementations(imageNamed, webImageNamed);</span><br><span class="line"></span><br><span class="line">/*******/方法实现内容</span><br><span class="line">#import &quot;UIImage+WebPUtils.h&quot;</span><br><span class="line">#import &lt;UIImage+WebP.h&gt;</span><br><span class="line"></span><br><span class="line">///根据scale  获取图片取用优先顺序</span><br><span class="line">static NSArray *_NSBundlePreferredScales() &#123;</span><br><span class="line">static NSArray *scales;</span><br><span class="line">static dispatch_once_t oneToken;</span><br><span class="line">dispatch_once(&amp;oneToken, ^&#123;</span><br><span class="line">CGFloat screenScale = [[UIScreen mainScreen] scale];</span><br><span class="line">if (screenScale &lt;= 1) &#123;</span><br><span class="line">scales = @[@1,@2,@3];</span><br><span class="line">&#125;else if (screenScale &lt;= 2)&#123;</span><br><span class="line">scales = @[@2,@3,@1];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">scales = @[@3,@2,@1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return scales;</span><br><span class="line">&#125;</span><br><span class="line">static NSString *_NSStringByAppendingNameScale(NSString *string, CGFloat scale) &#123;</span><br><span class="line">if (!string) return nil;</span><br><span class="line">if (fabs(scale - 1) &lt;= __FLT_EPSILON__ || string.length == 0 || [string hasSuffix:@&quot;/&quot;]) return string.copy;</span><br><span class="line">return [string stringByAppendingFormat:@&quot;@%@x&quot;, @(scale)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIImage (WebPUtils)</span><br><span class="line"></span><br><span class="line">+ (nullable UIImage *)pa_imageNamed:(nonnull NSString *)name &#123;</span><br><span class="line">if (!name) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 图片Bundle path</span><br><span class="line">NSString *path = @&quot;&quot;;</span><br><span class="line">/// 图片后缀 无为空字符串</span><br><span class="line">NSString *nameSuffix = name.pathExtension;</span><br><span class="line">if  (nameSuffix.length &gt; 0 &amp;&amp; ![nameSuffix isEqualToString:@&quot;webp&quot;])  &#123;</span><br><span class="line">return [UIImage pa_imageNamed:name];</span><br><span class="line">&#125;</span><br><span class="line">/// 图片名（去后缀）</span><br><span class="line">NSString *nameConten = name.stringByDeletingPathExtension;</span><br><span class="line">CGFloat imgScale = 1.0f;</span><br><span class="line">/// 保存图片scale</span><br><span class="line">if  ([nameConten hasSuffix:@&quot;@2x&quot;]) &#123;</span><br><span class="line">imgScale = 2.0f;</span><br><span class="line">&#125;else if ([nameConten hasSuffix:@&quot;@3x&quot;])&#123;</span><br><span class="line">imgScale = 3.0f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 图片取得顺序偏好</span><br><span class="line">NSArray *scales = _NSBundlePreferredScales();</span><br><span class="line"></span><br><span class="line">for (NSNumber *scale in scales) &#123;</span><br><span class="line">int s = scale.floatValue;</span><br><span class="line">NSString *scacleName = _NSStringByAppendingNameScale(nameConten, s);</span><br><span class="line">path = [[NSBundle mainBundle] pathForResource:scacleName ofType:@&quot;webp&quot;];</span><br><span class="line">if (path.length &gt; 0) &#123;</span><br><span class="line">if (s != 1) &#123;</span><br><span class="line">imgScale = scale.floatValue;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if  (!path)  &#123;</span><br><span class="line">return [UIImage pa_imageNamed:name];</span><br><span class="line">&#125;</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">// 设置scale</span><br><span class="line">UIImage *webPimage = [UIImage sd_imageWithWebPData:data];</span><br><span class="line">[webPimage setValue:@(imgScale) forKey:@&quot;scale&quot;];</span><br><span class="line">return webPimage;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h3><p>设置图片链接，和普通网络图片没有区别，<strong>SDWebImag</strong>已经的很好的支持了。另外 webview 也是可以使用 WebP，除了 H5 自己做处理之外，其实可以把图片任务交给 Native 来完成，这样可以减轻 Web 的压力，很大程度上提升页面性能，前端通过 JS 接口把图片地址传递给 App，然后 app 启动下载线程，完事回传给 H5。当然这都是大致思路，具体上肯定还要考虑批量下载、缓存问题。</p><h2 id="预览-WebP-格式图片"><a href="#预览-WebP-格式图片" class="headerlink" title="预览 WebP 格式图片"></a>预览 WebP 格式图片</h2><p>Google 家的 WebP 格式图片，在 Mac 上是无法直接快速查看或者用 预览.app 打开的，只能用 Chrome 查看，很不方便 …… 你可以安装 WebP 这款 QuickLook 扩展插件插件解决问题。安装这个 QuickLook 扩展插件后，不仅可以按空格键快速查看 WebP 格式图片，而且 Finder 和 Xcode 里也显示预览图了。<a href="https://github.com/dchest/webp-quicklook/releases">下载插件</a>，解压放到<code>/资源库/QuickLook/ </code>路径下即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总之，WebP 作为一个新的图片格式，对于 APP 性能优化方面大有可为，后续会探索更多可用点。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WebP（发音 weppy，&lt;a href=&quot;https://developers.google.com/speed/webp/&quot;&gt;项目主页&lt;/a&gt;），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的  WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/910527-557d9a3e234240e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;各个压缩比下WebP和PNG的体积对比&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="WebP" scheme="https://mryulong.github.io/tags/WebP/"/>
    
  </entry>
  
  <entry>
    <title>关于NSTimer内存释放问题</title>
    <link href="https://mryulong.github.io/2018/07/23/%E5%85%B3%E4%BA%8ENSTimer%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>https://mryulong.github.io/2018/07/23/%E5%85%B3%E4%BA%8ENSTimer%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/</id>
    <published>2018-07-23T08:20:23.000Z</published>
    <updated>2022-02-09T03:04:34.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><p>NSTimer 是一个很方便的计时器，日常开放中也广泛使用。我们可以选择安排在当前 Runloop 或者指定 Runloop 中执行，Runloop 会定时触发事件任务，通常我们会通过下面方法实例化出计时器对象，<strong>target</strong>和<strong>aSelector</strong>表示计时器会定时调用<strong>target</strong>的<strong>aSelector</strong>方法，所以计时器会保留<strong>target</strong>对象直到计时器被废除。如果指定定时器为重复模式，使用完毕需要调用<strong>invalidate</strong>方法来废除定时器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</span><br></pre></td></tr></table></figure><span id="more"></span><p>由于计时器会保留目标对象，所以重复模式下的定时器很容易造成循环引用(Retain Cycle)问题，比如：通常 NSTimer 都是全局变量被<strong>target</strong>强引用，而 NSTimer 对象有保留<strong>target</strong>，直到调用<strong>invalidate</strong>方法，然而正常情况无法保证<strong>invalidate</strong>一定会调用，这就导致<strong>target</strong>无法得到释放，如果计时器在执行复杂的任务可能还会造成更加复杂的泄漏问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="系统-API"><a href="#系统-API" class="headerlink" title="系统 API"></a>系统 API</h3><p>关于这个问题 iOS10 之后，系统给出了另外一个函数，通过 block 代码块方式引用 weakself，可切断循环引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="兼容旧版本"><a href="#兼容旧版本" class="headerlink" title="兼容旧版本"></a>兼容旧版本</h3><p>然而以上三个方法只能针对 iOS10 之后才能调用，适配之前的系统就尴尬了，其实我们也可以按照系统形式把执行任务封装成 block，把它作为<strong>userinfo</strong>传进去并 copy 下，否则下面方法需要执行 block 时候就已经无效了，现在的 target 是 NSTimer 的类对象，这个时候计时器是否保留 target 都无所谓了，毕竟类对象无需回收。主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (NSTimer *)mytest_scheduledTimerWithTimeInterval:(NSTimeInterval)interval andTimeIntervalBlock:(void(^)(void))block repeats:(BOOL)yesOrNo&#123;</span><br><span class="line"></span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(timerBlockSelector:) userInfo:[block copy] repeats:yesOrNo];</span><br><span class="line">    return timer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)timerBlockSelector:(NSTimer *)timer&#123;</span><br><span class="line"></span><br><span class="line">    void(^block)(void) = timer.userInfo;</span><br><span class="line"></span><br><span class="line">    if (block) &#123;</span><br><span class="line"></span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话依旧可以达到系统 API 的效果，然而这样依旧需要在适当的时候调用<strong>invalidate</strong>来废除计时器。还有一个问题就是，通过<strong>userInfo</strong>把代码块传入<strong>timerBlockSelect</strong>方法，如果需要用<strong>userInfo</strong>传其他值，就被占用了，可以通过扩展一个属性来保存代码块，以便于在<strong>timerBlockSelect</strong>方法中调用。</p><h3 id="中间类方法"><a href="#中间类方法" class="headerlink" title="中间类方法"></a>中间类方法</h3><p>创建一个 Timer 的的 Category，引用一个中间类作为 NSTimer 的<strong>target</strong>，<strong>selector</strong>为中间类的<strong>timerAction</strong>，中间类<strong>weak</strong>引用<strong>self</strong>,这样就切断循环引用(Retain Cycle)，且在<strong>sourceTarget</strong>为 nil 时<strong>invalidate</strong>计时器，使用者不用额外调用 invalidate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface MYTimerTarget ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) id sourceTarget;</span><br><span class="line">@property (nonatomic, assign) SEL targetSelector;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MYTimerTarget</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSelector:(SEL)aSelector  sourceTarget:(id)sourceTarget&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.sourceTarget = sourceTarget;</span><br><span class="line">        self.targetSelector = aSelector;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)timerAction:(NSTimer *)timer&#123;</span><br><span class="line">    if (self.sourceTarget == nil) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        timer = nil;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        IMP imp = [self.sourceTarget         methodForSelector:self.targetSelector];</span><br><span class="line">        void (*targetSelector)(id, SEL,NSTimer *) = (void *)imp;</span><br><span class="line">        targetSelector(self.sourceTarget, self.actionSelector,timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (Utils)</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)ll_scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo&#123;</span><br><span class="line"></span><br><span class="line">    MYTimerTarget *timerTarget = [[MYTimerTarget alloc]initWithSelector:aSelector sourceTarget:aTarget];</span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:ti target:timerTarget selector:@selector(timerAction:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">    return timer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NSTimer 的循环引用关键在于，内部对 target 的强引用，只要切断其中一环，就能解决循环引用问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存问题&quot;&gt;&lt;a href=&quot;#内存问题&quot; class=&quot;headerlink&quot; title=&quot;内存问题&quot;&gt;&lt;/a&gt;内存问题&lt;/h2&gt;&lt;p&gt;NSTimer 是一个很方便的计时器，日常开放中也广泛使用。我们可以选择安排在当前 Runloop 或者指定 Runloop 中执行，Runloop 会定时触发事件任务，通常我们会通过下面方法实例化出计时器对象，&lt;strong&gt;target&lt;/strong&gt;和&lt;strong&gt;aSelector&lt;/strong&gt;表示计时器会定时调用&lt;strong&gt;target&lt;/strong&gt;的&lt;strong&gt;aSelector&lt;/strong&gt;方法，所以计时器会保留&lt;strong&gt;target&lt;/strong&gt;对象直到计时器被废除。如果指定定时器为重复模式，使用完毕需要调用&lt;strong&gt;invalidate&lt;/strong&gt;方法来废除定时器。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://mryulong.github.io/categories/iOS/"/>
    
    
    <category term="NSTimer" scheme="https://mryulong.github.io/tags/NSTimer/"/>
    
  </entry>
  
</feed>
